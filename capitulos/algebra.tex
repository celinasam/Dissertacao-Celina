\chapter{Álgebra Abstrata}

% sobre Stephen B. Weinstein http://jcn.or.kr/home/journal/bio/bio1.html
% http://www.ie.cuhk.edu.hk/fileadmin/seminar/2009pdf/sem3509_Stephen%20B.%20Weinstein_051109%20(SCL).pdf


{\small
\begin{align*}
&& In\ Galois\ fields,\ full\ of\ flowers.\\
&& Primitive\ elements\ dance\ for\ hours \ldots\\
&& Stephen\ B.\ Weinstein
\end{align*}
}


Esse capítulo tem por objetivo apresentar conceitos matemáticos fundamentais
dentro do escopo de álgebra abstrata para entendimento de Códigos de Blocos~\cite{Hefez:2008}.

Códigos BCH e RS são projetados através da aritmética de corpos finitos. Corpos finitos
também são chamados corpos de Galois, em homenagem ao matemático francês Évariste Galois~\cite{Connell:2004}.

\section{Definições em $\mathbb{Z}$}

Os alfabetos que utilizamos nas definições deste capítulo são o conjunto $\mathbb{Z}$ e o seu sub-conjunto $\mathbb{A}\ =\ \{ 0, 1\}$.

\begin{definition} {\bf Congruência Linear} \index{Congruência Linear} Seja $q \in \mathbb{Z}$. Dois inteiros $a$
 e $b$ dizem-se congruentes módulo$-q$ se tiverem o mesmo resto na divisão por
 $q$. A notação é $a \equiv b(mod\ q)$. Daí temos que $a = qk + b$, para um $k \in \mathbb{Z}$.
\end{definition}

\begin{example}
\begin{align*}
& 32 \equiv 2(mod\ 3)\\
& 27 \equiv 5(mod\ 11)\\
& 63 \equiv 7(mod\ 8)
\end{align*}
\end{example}


\begin{definition} {\bf Classe Residual} \index{Classe Residual} Seja $q \in \mathbb{Z}$ e $q > 1$. A classe
residual módulo $q$ do elemento $a \in \mathbb{Z}$ pode ser assim definida:

\begin{align*}
& \bar{a}\ =\ \{ x \in \mathbb{Z}\ tal\ que\ x \equiv a(mod\ q)\}
\end{align*}

\end{definition}

\begin{example}
\begin{align*}
& Se\ m\ =\ 2,\ temos\ 2\ classes\ residuais:\ \bar{0}\ =  \{ \ldots  -4, -2, 0, 2, 4, \ldots \}\ e\  \bar{1}\ =\ \{ \ldots  -3, -1, 1, 3, \ldots \}\\
& Se\ m\ =\ 3,\ temos\ 3\ classes\ residuais:\  \bar{0}, \bar{1}, \bar{2}\\
& Se\ m\ =\ 5,\ temos\ 4\ classes\ residuais:\ \bar{0}, \bar{1}, \bar{2}, \bar{3}, \bar{4}
\end{align*}
\end{example}

\begin{definition} {\bf Conjunto das Classes Residuais} \index{Conjunto das Classes Residuais} Seja $\mathbb{Z}_q = \{\bar{0}, \bar{1}, \ldots , \overline{q-1}\}$ o conjunto das classes residuais dos inteiros módulo $q$. 
\end{definition}

Notemos que $\mathbb{Z}_q$ tem exatamente $q$ elementos, portanto $\mathbb{Z}_q$ é finito.

\begin{property} Se a$\ \equiv\ b(mod\ q)$, então $\bar{a} = \bar{b}$.
\end{property}

Com o objetivo de determinar quais são os $\mathbb{Z}_q$ que são corpos, vamos apresentar mais alguns conceitos em $\mathbb{Z}$.

\begin{definition} {\bf Máximo Divisor Comum} \label{mdc} \index{Máximo Divisor Comum} Seja $a$ e $b \in \mathbb{Z}$ com $a \neq 0$ ou $b \neq 0$. O $MDC$ de $a$ e $b$ é $d \in \mathbb{Z}$, se as condições forem verdadeiras:
  \begin{enumerate}[(i)]
     \item $d$ é um divisor comum de $a$ e $b$, ou seja, $d\ |\ a$ e $d\ |\ b$
     \item $d$ é divisível por todo divisor comum de $a$ e $b$, ou seja, $\exists c \in \mathbb{Z},\ c\ |\ a\ e\ c\ |\ b\ \Longrightarrow\ c\ |\ d$.
  \end{enumerate}
\end{definition}

\begin{lemma} {\bf Divisão Euclidiana} \label{DivEucli} \index{Divisão Euclidiana} Dados $a \in \mathbb{Z}$, $b \in \mathbb{Z}$ e $b \neq 0$, $\exists c,\ \exists r$ inteiros únicos $\in\ \mathbb{Z}$ tais que $a\ =\ bc\ +\ r$ e $0 \leq r < |b|$. Então o $MDC(a,b)\ =\ MDC(b,r)$.
\end{lemma}

$c$ e $r$ são chamados, respectivamente, o quociente e resto da divisão de a por b. O algoritmo euclidiano, um método eficiente para calcular o MDC~\cite{Rosen:2003}, usa o lemma~\ref{DivEucli}. 

\begin{theorem} {\bf Lema de Euclides} \label{euclides} \index{Lema de Euclides} Sejam $a$ e $b \in \mathbb{Z}$ não-nulos e seja $d\ =\ MDC(a,b)$. Então, $\exists \lambda, \mu \in \mathbb{Z}$ tais que $d\ = \ \lambda a\ + \mu b$.
 \end{theorem}

\begin{proposition} \label{primos} Dois inteiros $a$  e $b$ são primos entre si se, e somente se, $\exists \lambda, \exists \mu \in\ \mathbb{Z}$ tais que $\lambda a\ +\ \mu b\ =\ 1$.
\end{proposition}

\begin{proof}
Se $a$ e $b$ são primos entre si, então $MDC(a,b)=1$ e pelo lema~\ref{euclides}, temos que  $\exists \lambda, \ \exists \mu \in\ \mathbb{Z}$ tais que $MDC(a,b)\ =\ \lambda a\ +\ \mu b$.  Então: 
\begin{align*}
& MDC(a,b)\ & =\ \lambda a\ +\ \mu b\ =\ 1\ (multiplica-se\ ambos\ os\ lados\ por\ d\ =\ MDC(a,b))\\
& d(\lambda a\ +\ \mu b)\ =\ d
\end{align*}

Se $\lambda a\ +\ \mu b\ =\ 0$, então $d\ =\ 0$, o que é um absurdo.

Se $\lambda a\ +\ \mu b\ <\ 0$, então  $d\ <\ 0$ e $\lambda a\ +\ \mu b\ >\ 0$, o que é um absurdo.

Se $\lambda a\ +\ \mu b\ >\ 0$, vamos chamar esse resultado de $d^{'}$.

\begin{align*}
& dd^{'}\ =\ d
\end{align*}

Nesse caso, sabemos que $d^{'}\ =\ 1$.

Suponhamos que $\exists \lambda, \ \exists \mu \in\ \mathbb{Z}$ tais que $\lambda a\ +\ \mu b\ =\ 1$. 
$$
\begin{array}{cl}
\lambda a\ +\ \mu b\ =\ 1\ (divide-se\ ambos\ os\ lados\ por\ d\ =\ MDC(a,b))\\
\frac{\lambda a\ +\ \mu b}{d}\ =\ \frac{1}{d}\\
\frac{\lambda a}{d}\ +\ \frac{\mu b}{d}\ =\ \frac{1}{d}
\end{array}
$$
Sabemos que $MDC(a,b)\ |\ a$ e $MDC(a,b)\ |\ b$. Portanto, $\frac{a}{d}, \frac{b}{d} \in \mathbb{Z}$. Podemos chamar  $\frac{a}{d}$ de $c$ e $\frac{b}{d}$ de $d$.
$$
\lambda c\ +\ \mu d\ =\ \frac{1}{d}
$$
Pelo lema~\ref{euclides}, então  $\frac{1}{d}$ é o $MDC(c, d) \in \mathbb{Z}$. Nesse caso, sabemos que $d\ =\ 1$. 
$\square$
\end{proof}

\begin{proposition} \label{invertivel} Para  $[a] \in \mathbb{Z}_q$  é invertível se, e somente se, $MDC(a,q)=1$.
\end{proposition}

\begin{proof}
Suponhamos que $[a]$ seja inversível. Assim, $\exists b \in \mathbb{Z}$ tal que $[a].[b]\ =\ 1$. Assim, $[a.b]\ =\ 1$ e $a.b \equiv 1\ mod\ q$. Isso implica que $\exists s$ tal que $ab\ +\ sq\ =\ 1$. Pela proposição~\ref{primos}, implica que $MDC(a,q)\ =\ 1$.

Suponhamos que $MDC(a,m)\ =\ 1$. Pela proposição~\ref{primos}, $\exists b, c \in \mathbb{Z}$ tais que $ba\ +\ cm\ =\ 1$. Assim, $b.a \equiv 1\ mod\ q$. Portanto, $[a].[b]\ =\ [a.b]\ =\ 1$.
$\square$
\end{proof}

\section{Espaço Vetorial, Grupo, Anel e Corpo de Galois}

\begin{definition} {\bf Espaço Vetorial} \label{EspVet} \index{Espaço Vetorial} Um espaço vetorial $\mathbb{V}$ é um conjunto não vazio de objetos chamados vetores e as suas duas operações chamadas adição e multiplicação com números reais, que seguem 10 propriedades. As propriedades são válidas para $\forall u, v, w \in V$ e $a, b \in \mathbb{R}$.
   \begin{enumerate}[(i)]
      \item a soma $v + u \in V$ 
      \item $u + v\ =\ v + u$
      \item $(u + v) + w\ =\  u + (v + w)$
      \item $\exists 0 \in V$ um vetor zero tal que $u + 0\ =\ u$
      \item $\forall u \in V \exists -u \in V$ um vetor tal que $u + (-u)\ =\ 0$
      \item $a.u \in V$
      \item $a.(u + v)\ =\ a.u + a.v$
      \item $(a+b).u\ =\ a.u + b.u$
      \item $a(b.u)\ =\ (ab).u$
      \item $1.u\ =\ u$
   \end{enumerate}
\end{definition}

\begin{definition} {\bf Subespaço Vetorial} \label{SubEspVet} \index{Subespaço Vetorial} Dado um espaço vetorial $\mathbb{V}$, um subconjunto $W$ não vazio é um subespaço vetorial de $V$ se:
   \begin{enumerate}[(i)]
      \item $\forall u,v \in W$, temos que $u + v \in W$
      \item $\forall a \in \mathbb{R}, \forall u \in W$, temos que $a.u \in W$
   \end{enumerate}
\end{definition}

\begin{definition} {\bf Independência Linear} \label{IndepLin} \index{Independência Linear} Sejam $V$ um espaço vetorial e $v_1, \ldots, v_n \in V$. Dizemos que o conjunto $\{ v_1, \ldots, v_n\}$ é linearmente independente, se a equação $a_1v_1 + \ldots + a_nv_n=0$ implica que $a_1=a_2= \ldots =a_n=0$. Se $\exists a_i \neq 0$, dizemos que $\{ v_1, \ldots, v_n\}$ é linearmente dependente.
\end{definition}


\begin{definition} {\bf Combinação Linear} \label{CombLin} \index{Combinação Linear}  Sejam $V$ um espaço vetorial, $v_1, \ldots, v_n \in V$ e $a_1, \ldots a_n \in \mathbb{Z}$. O vetor da forma $v=a_1v_1 + \ldots + a_nv_n$ é um elemento de $V$ e o chamamos de combinação linear de $v_1, \ldots, v_n$.
\end{definition}

\begin{theorem} {\bf Dependência Linear} \label{DepLin} \index{Dependência Linear}  O conjunto $\{ v_1, \ldots, v_n\}$ é linearmente dependente se, e somente se, $\exists v_i$ tal que $v_i$ é uma combinação linear de $v_j, j \neq i, 1 \leq j \leq n$.
\end{theorem}

\begin{definition} {\bf Operação Binária} \label{OperBin} \index{Operação Binária} $\mathbb{G}$ é um conjunto não vazio, $\phi$ : $\mathbb{G}\ X\ \mathbb{G} \rightarrow \mathbb{G}$, é uma função. $\phi$ é chamada operação binária tal que  $\phi(a,b)\ =\ a+b $ ou $\phi(a,b)\ =\ a.b$. Considere as seguintes propriedades:
  \begin{description}
     \item [Associatividade] Se $a, b, c \in G$ então $a+(b+c)\ =\ (a+b)+c$. Se $a, b, c \in G$ então $a.(b.c)\ =\ (a.b).c$. 
     \item [Elemento Neutro] $\exists 0 \in G$ tal que se $a \in G$ $0\ +\ a\ =\ a\ +\ 0\ =\ a$. $\exists e \in G$ tal que se $a \in G$ $e.a\ =\ a.e =\ a$.
     \item [Elemento Inverso]  Se $a \in G, \exists b \in G$ tal que $a + b = b + a = 0$. $b$ é escrito como $b = -a$. Se $a \in G, \exists b \in G$ tal que $a.b\ =\ b.a\ =\ e$. $b$ é escrito como $b = a^{-1}$.
     \item [Comutatividade] Se $a, b \in G$ então $a + b = b + a$. Se $a, b \in G$ então $a . b = b . a$.
  \end{description}
\end{definition}

\begin{definition} {\bf Grupo} \label{grupo} \index{Grupo} Se $(G, \phi)$ é um grupo, então satisfaz as propriedades associatividade, elemento neutro e elemento inverso. Se $\phi(a,b)\ =\ a+b$, então $G$ é um grupo aditivo. Se $\phi(a,b)\ =\ a.b$, então $G$ é um grupo multiplicativo. Se o grupo $(G, \phi)$ satisfaz a propriedade de comutatividade, ele é um grupo abeliano ou comutativo.
\end{definition}

\begin{definition} {\bf Classe de Conjugação} \label{clconj} \index{Classe de Conjugação} Dois elementos $a, b \in G$ são chamados conjugados, se $\exists g \in G$ tal que $gag^{-1}\ =\ b$. A classe de equivalência que contém o elemento $a \in G$ é $Cl(a)\ =\ \{gag^{-1}:\ g \in G \}$ e é chamado a classe de conjugação de $a$.
\end{definition}

\begin{definition} $A$ é um grupo comutativo aditivo, não vazio, e $\exists \varphi$ um segunda operação binária $A\ X\ A \rightarrow A$ chamada multiplicação. Considere as seguintes propriedades:
  \begin{description}
     \item [Associatividade] Se $a, b, c \in A$ então $a.(b.c)\ =\ (a.b).c$.
     \item [Distributividade da multiplicação com relação a adição] Se $a, b, c \in A$ $a.(b+c)\ =\ (a.b)\ +\ (a.c)$ e $(b+c).a\ =\ (b.a)\ +\ (c.a)$.
     \item [Elemento Neutro] $\exists 1 \in A$ tal que se $a \in G$ $1.a\ =\ a.1 =\ a$.
     \item [Comutatividade] Se $a, b \in A$ então $a . b = b . a$.
  \end{description}
\end{definition}

\begin{example}
Para um dado número primo $p$, o conjunto de números inteiros $\{0, 1, 2, . . . , p - 1\}$ é um grupo comutativo com relação à adição módulo-$p$. O conjunto de números inteiros $\{1, 2, . . . , p - 1\}$ é um grupo comutativo com relação à multiplicação módulo-$p$.
\end{example}

\begin{definition} {\bf Anel} \label{anel} \index{Anel} Se $(A, \phi, \varphi)$ é um anel, então satisfaz as propriedades associatividade, distributividade da multiplicação com relação a adição e elemento neutro. Se ele também satisfaz a propriedade comutatividade, $(A, \phi, \varphi)$ é um anel comutativo.
\end{definition}

\begin{example}
Como exemplos de anéis comutativos, temos os conjuntos dos números racionais $\mathbb{Q}$, reais $\mathbb{R}$, complexos $\mathbb{C}$ e e inteiros $mod\ q$ ($q$ é primo) sob as operações de adição e multiplicação usuais.
\end{example}

\begin{definition} {\bf Domínio de Integridade} \label{DomInt} \index{Domínio de Integridade} Um anel $A$ é chamado domínio de integridade, se possuir a propriedade: $\forall a,b, \in A\ e\ a\neq 0\ e\ b \neq 0 \Longrightarrow a.b \neq 0$
\end{definition}

\begin{example} Os anéis $\mathbb{Z}$, $\mathbb{Q}$, reais $\mathbb{R}$, $\mathbb{C}$ são todos domínios de integridade. O anel $\mathbb{Z}_q$ é um domínio de integridade, quando $q$ é um número primo.
\end{example}

\begin{theorem} O anel $\mathbb{Z}_q$  é um corpo se, e somente se, $q$ é um número primo.
\end{theorem}

\begin{proof}
Se $\mathbb{Z}_q$ é um corpo se, e somente se, todos os seus elementos $\bar{0}, \bar{1}, \ldots , \overline{q-1}$ são inversíveis. Pela proposição~\ref{invertivel}, significa que  $MDC(0,q)\ =\ MDC(1,q)\ =\ MDC(2,q)\ = \ldots \ =\ MDC(q-1,q)\ =\ 1$. Portanto, $q$ é primo. $\square$
\end{proof}

\begin{definition} {\bf Corpo} \label{corpo} \index{Corpo} Um anel onde todo elemento não nulo é invertível é chamado de Corpo.
\end{definition}

\begin{example} O Corpo de Galois $\mathbb{GF}_2$ é o conjunto $\mathbb{A}\ =\ \{0, 1\}$ e as operações $+$ e $.$. O $\mathbb{GF}_8$ ilustrado nas tabelas~\ref{tab5:comp} e~\ref{tab6:comp}.
\end{example}

   \input{tabelas/tabela-operacoes-corpo-galois}
   \input{tabelas/tabela-operacoes-corpo-galois8}

%\section{Corpo}
%	Um corpo é um conjunto $F$  que resume-se um espaço fechado com operações binárias, como "$.$" e "$+$", entre dois dos seus elementos, designados por operandos. O resultado da aplicação de uma operação resulta em um terceiro elemento também pertencente a $F$. As propriedades dessas operações são: associativa e comutativa e a operação "$.$" é distributiva sobre a operação "$+$" : $a.(b + c)\ =\ a.b\ +\ a.c,\ \forall a,\ \forall b,\ \forall c\ \in\ F$. Os elementos de $F$ apresentam essas propriedades: existência de elemento identidade (neutro) em $F$ para a operação "$.$" e para a operação "$+$" e existência de elemento um inverso da operação "$+$" para cada elemento de $F$.

%	Os conjuntos como $F$ podem ter ordem (por exemplo, cardinalidade) infinita. Como exemplos de corpos infinitos, temos os conjuntos dos números racionais $\mathbb{Q}$, reais $\mathbb{R}$, complexos $\mathbb{C}$ e e inteiros $mod\ p$ ($p$ é primo) sob as operações de adição e multiplicação usuais.

%	\section{Corpo de Galois}
%	Um Corpo de Galois é um corpo de ordem finita ou seja, sua cardinalidade é conhecida.

%	Exemplo: Seja o conjunto $G = \{ 0, 1 \}$ e a operação binária $\bigoplus$ em $G$: $0 \bigoplus 0 = 0$, $0 \bigoplus 1 = 1$, $1 \bigoplus 0 = 1$, $1 \bigoplus 1 = 0$.

%	A operação $\bigoplus$ é chamada adição módulo 2. Portanto $G$ é fechado em $\bigoplus$ e $\bigoplus$ é comutativa. Também é possível demonstrar que $\bigoplus$ é associativa. O elemento $0$ é o elemento identidade. Os inversos de cada um dos elementos de $G$ também pertencem a $G$.


\begin{theorem} {\bf $\mathbb{GF}_q$} \label{GFq} \index{$\mathbb{GF}_q$} Seja $\mathbb{GF}_q$ um corpo finito com $q$ elementos. Então:
   \begin{enumerate}[(i)]
     \item $q = p^n$ para algum primo $p$ e para algum inteiro positivo $n$,
     \item $\mathbb{GF}_q$ contém o sub-campo $\mathbb{GF}_p$,
     \item $\mathbb{GF}_q$ é um espaço vetorial sob $\mathbb{GF}_p$ de dimensão $n$,
     \item $p\alpha\ =\ 0$ para todo $\alpha \in \mathbb{GF}_q$ e
     \item Isomorfismo: \index{Isomorfismo entre Corpos} Dados dois corpos finitos $C_q$ e $G_q$, ambos com $q$ elementos, existe uma única bijeção $f\ :\ C_q \rightarrow G_q$ com $f(a+b)=f(a)+f(b)$ e $f(a.b)=f(a).f(b)$ para $\forall a,b \in C_q$. Dizemos que  $C_q$ é isomorfo a $G_q$.
   \end{enumerate}
\end{theorem}


\begin{theorem} \label{teorema1} Seja $\mathbb{GF}_q$ um corpo finito e $a \in \mathbb{GF}_q$ não nulo. Então $a^{q-1}\ =\ 1$.
\end{theorem}

\begin{proof} Seja $b_1, b_2, \ldots , b_{q-1}$ os $q-1$ elementos não nulos de $\mathbb{GF}_q$. Os $q-1$ números  $a.b_1$, $a.b_2 \ldots  a.b_{q-1}$ são todos não nulos e distintos. Sabemos que pela operação multiplicação

$$
\begin{array}{cl}
(a.b_1).(a.b_2). \ldots  .(a.b_{q-1})\ =\ b_1.b_2. \ldots  .b_{q-1}\\
a^{q-1}.(b_1.b_2. \ldots  .b_{q-1})\ =\ b_1.b_2. \ldots  .b_{q-1}
\end{array}
$$

Como $a \neq 0$ e $(b_1.b_2 \ldots  b_{q-1}) \neq 0$, logo $a^{q-1}\ =\ 1$. $\square$
\end{proof}


\begin{definition} {\bf Ordem do Corpo} \label{OrdCorpo} \index{Ordem do Corpo} O número de elementos de um corpo finito $G$ é denominado ordem de $G$. Um corpo de Galois de ordem $q$ é representado por $\mathbb{GF}_q$. Um corpo finito G tem ordem $p^n$, onde $p$ é a característica do corpo $G$ e $n = [K: Z_p]$.
\end{definition}

\begin{proposition}
Todo o corpo finito tem $p^n$ elementos para algum primo $p$ e algum $n \in \mathbb{Z}^+$.
\end{proposition}

\begin{proof}
\end{proof}

\begin{proposition}
Para cada primo $p$ e para cada  $n \in \mathbb{Z}^+$, existe um corpo com $p^n$ elementos.
\end{proposition}

\begin{proof}
\end{proof}

\begin{proposition}
Qualquer corpo com $p^i$ elementos é isomorfo à extensão de decomposição de $x^q - x, q = p^i$ sobre $\mathbb{GF}_q$.
\end{proposition}

\begin{proof}
\end{proof}

\begin{example}
\begin{align*}
& Corpo\ de\ Galois\ de\ ordem\ 3:\ \mathbb{GF}_3 = \{0, 1, 2\}\\
& Corpo\ de\ Galois\ de\ ordem\ 4:\ \mathbb{GF}_3 = \{0, 1, 2, 3\}\\
& Corpo\ de\ Galois\ de\ ordem\ 5:\ \mathbb{GF}_5 = \{0, 1, 2, 3, 4\}\\
& Corpo\ de\ Galois\ de\ ordem\ 7:\ \mathbb{GF}_7 = \{0, 1, 2, 3, 4, 5, 6\}
\end{align*}
\end{example}

\begin{definition} {\bf Ordem do Elemento} \label{OrdElem} \index{Ordem do Elemento} Seja $a \in \mathbb{GF}_q$ não nulo. A ordem de $a$, representada por $ord(a)$, é o menor inteiro positivo $o$ tal que $a^o\ =\ 1$.
\end{definition}

\begin{property} Se elevarmos ambos os lados a potência $q - 1$, temos que $(a^o)^{q - 1} = 1$. Multiplicando ambos os lados por $a^o$, temos que $(a^o)^q = a^o$ e substituindo $a^o$ por $x$, temos $x^q = x$. Portanto, todos os $a \in \mathbb{GF}_q$ satisfazem a equação: $x^q - x = 0, q = p^n$.
\end{property}

\begin{theorem} \label{teorema2} Seja $\mathbb{GF}_q$ um corpo finito e $a \in \mathbb{GF}_q$ não nulo. Seja $o$ a ordem de $a$. Então $o\ |\ q-1$.
\end{theorem}

\begin{proof} Suponhamos que $o \nmid q-1$. Assim, $q-1\ =\ ko\ +\ r$, onde $0 < r < o$.
$$
\begin{array}{cl}
a^{q-1}\ =\ a^{ko+r}\ =\ a^{ko}.a^r\ =\ (a^o)^k.a^r
\end{array}
$$
Pelo teorema~\ref{teorema1}, $a^{q-1}\ =\ 1$ e $a^o\ =\ 1$, então $a^r\ =\ 1$. Isso é um absurdo, pois $0 < r < o$ e pela definição~\ref{OrdElem}, $o$ é o menor inteiro positivo tal que $a^o\ =\ 1$. Portanto, $o\ |\ q-1$. $\square$
\end{proof}

\begin{definition} {\bf Adição módulo-$m$} \label{AdicaoM} \index{Adição módulo-$m$} Seja $a,b  \in \mathbb{GF}_q$ não nulos. A operação adição módulo-$m$ é definida  como:
\begin{align*}
& a \oplus b\ =\ c\\
& c\ =\ (a+b)(mod\ m)
\end{align*}
Isso é, a adição de quaisquer dois elementos $a,b \in \mathbb{GF}_q$ é o resto da divisão da adição aritmética $(a+b)$ por $m$.
\end{definition}

\begin{definition} {\bf Multiplicação módulo-$m$} \label{MultiM} \index{Multiplicação módulo-$m$} Seja $a,b  \in \mathbb{GF}_q$ não nulos. A operação multiplicação módulo-$m$ é definida  como:
\begin{align*}
& a \otimes b\ =\ c\\
& c\ =\ (a.b)(mod\ m)
\end{align*}
Isso é, a multiplicação de quaisquer dois elementos $a,b \in \mathbb{GF}_q$ é o resto da divisão da multiplicação aritmética $(a.b)$ por $m$.
\end{definition}

\begin{definition} 
Dado um campo $\mathbb{GF}_q$, as operações adição e multiplicação seguem as seguintes propriedades:
\begin{enumerate}[(i)]
   \item $\mathbb{GF}_q$ é um anel comutativo com relação a operação de adição. O elemento $0$ é o elemento neutro.
   \item ${\mathbb{GF}_q}^*$ é um anel comutativo com relação a operação de multiplicação. O elemento $1$ é o elemento neutro.
   \item a operação multiplicação é distributiva com relação a adição:
      \begin{align*}
         & a \otimes (b \oplus c)\ =\ (a \otimes b) \oplus (a \otimes c)
      \end{align*}
\end{enumerate}
\end{definition}

\begin{definition} {\bf Elemento Primitivo} \label{ElemPrim} \index{Elemento Primitivo} Seja $a \in \mathbb{GF}_q$ não nulo. $a$ é chamado elemento primitivo se a ordem de $a$ é $q-1$. Todos os campos tem um elemento primitivo.
\end{definition}

\begin{proposition} Todas potências do elemento primitivo geram todos os elementos não nulos de $\mathbb{GF}_q$. 
\end{proposition}

\begin{proof}
\end{proof}

\begin{proposition} Todos os campos tem pelo menos um elemento primitivo.
\end{proposition}

\begin{proof}
\end{proof}

\begin{proposition}  Cada elemento $b \in \mathbb{GF}_q$ não nulo pode ser representado através de um conjunto com potências de um elemento primitivo, com o expoente variando de $1$ até $q-1$.
\end{proposition}

\begin{proof}
Pela definição~\ref{OrdElem}, $b^o\ =\ 1$, onde $o$ é a ordem de $b$. Pelo teorema~\ref{teorema2}, $o\ |\ q-1$. Pelo teorema~\ref{teorema2}, $b^{q-1}\ =\ 1$. Seja $\alpha$ o elemento primitivo de $\mathbb{GF}_q$. 
$$
\begin{array}{cl}
a^i, i = 1, a = a\\
a^{q-1}\ =\ 1\\
b^{q-1}.a^{q-1}\ =\ b^{q-1}\\
\end{array}
$$
\end{proof}

%		\subsection{Aritmética de Corpo Binário}

\begin{theorem} {\bf Pequeno Teorema de Fermat} \label{Fermat} \index{Pequeno Teorema de Fermat}
Se $p$ é um número primo e $p \nmid a$, então $a^{p-1} \equiv 1(mod\ p)$ para $\forall a \in \mathbb{Z}$. Além disso, $a^p \equiv a(mod\ p)$.
Portanto, $p\ |\ a^p\ -\ a$. \cite{Rosen:2003}
\end{theorem}

\begin{proof} Seja $P(n)$ a proposição que $p\ |\ n^p\ -\ n$ para $\forall n \in \mathbb{Z}$ e para $p$ primo.

Base: em $P(1)$ é verdadeira, pois $1^p\ -\ 1$ é divisível por $p$.

Passo de indução: Suponhamos que P(k) é verdadeira $\forall k \in \mathbb{Z}$ e para $p$ primo.

Queremos provar, para $k+1$, que P(k+1) é verdadeira. Podemos escrever $(k+1)^p$ da seguinte forma:
$$
(k+1)^p\ =\ k^p\ +\ ip\ +\ 1,\ para\ i \in \mathbb{Z}
$$
Subtraindo $(k+1)$ em ambos os lados, temos que:
$$
(k+1)^p\ -\ (k+1)\ =\ ip\ +\ (k^p-k)
$$
Como $(k^p-k)$ é divisível por $p$ por hipótese, temos que $(k+1)^p - (k+1)$ é divisível por $p$.
$\square$
\end{proof}

\section{Anéis de Polinômios}

\begin{definition} {\bf Anel de Polinômios} \label{AnelPol} \index{Anel de Polinômios} Dado um corpo $\mathbb{GF}_p$ definimos o anel comutativo com unidade $\mathbb{GF}_p[x]$ como sendo o conjunto das expressões da forma $P[x]\ =\ a_o\ +\ a_1x\ +\ a_2x^2\ + \ldots +\ a_{n-1}x^{n-1}\ +\ a_nx^n$, com $a_n \neq 0$ e $n \in \mathbb{Z}^+$ chamados de polinômios com coeficientes em $\mathbb{GF}_p$. Cada polinômio define uma função polinomial $p(c)\ :\ \mathbb{GF}_p \rightarrow \mathbb{GF}_p$, $c \longmapsto\ p(c)\ =\ a_o\ +\ a_1c\ +\ a_2c^2\ +\ \ldots +\ a_nc^n$. A distinção entre um polinômio e uma função polinomial é bem ilustrada pelo polinômio $x^p-x,\ x \in \mathbb{Z}$. Pelo teorema~\ref{Fermat}, a função polinomial $p(x)\ =\ x^p-x$ tem propriedades diferentes do polinômio equivalente, onde para $\forall x \in \mathbb{Z}$, temos que $P[x]\ =\ 0$.
\end{definition}

%		\subsection{Propriedades dos Polinômios e suas Raízes}		
%		$\mathbb{GF}_q[x]$ é um corpo de Galois que tem ordem $q$, sobre o qual são aplicados polinômios com coeficientes entre $0$ e $q - 1$. Um exemplo de um polinômio $P[x]$ pode ser apresentado na equação: $P[x] = a_7.x^7 + a_5.x^5 + a_2.x^2 + ax + 1$. Os coeficientes de um polinômio $a_i$ pertencem ao $\mathbb{GF}_q[x]$.

\begin{theorem}
Sejam $f$ e $g$ dois polinômios não nulos em $\mathbb{GF}_p[x]$. Então:
  \begin{enumerate}[(i)]
     \item $fg$ é um polinômio não nulo
     \item o grau de $f.g$ é igual a soma do grau de $f$ mais o grau de $g$
     \item $fg$ é um polinômio de grau 1 se, e somente se, $f$ e $g$ são polinômios de grau 1
     \item $fg$ é um polinômio de grau 0 se, e somente se, $f$ e $g$ são polinômios de grau 0
     \item se $f+g \neq 0$, $grau(f+g) \leq max (grau(f), grau(g))$
  \end{enumerate}
\end{theorem}

\begin{proof}
Suponhamos que $f$ tenha grau $m$ e que $g$ tenha grau $n$. Se $k \in \mathbb{Z}^+$, temos que
$$
(fg)_{m+n}\ = \displaystyle\sum_{i=0}^{m+n+k} f_i g_{m+n+k-i}
$$
Sabemos que $i \leq m$ e $m+n+k-i \leq n$. Assim é necessário que $m+k \leq i \leq m$, que implica que $k=0$ e $i=m$. Então
$$
(fg)_{m+n}\ =\ f_m g_n
$$
e
$$
(fg)_{m+n+k}\ =\ 0
$$
\end{proof}

\begin{corollary} Suponhamos que f, g e h são polinômios em $\mathbb{GF}_p[x]$ tais que $f \neq 0$ e $fg\ =\ fh$. Então $g\ =\ h$.
\end{corollary}

\begin{proof} Suponhamos que $fg\ =\ fh$.
$$
f(g\ -\ h)\ =\ 0
$$
Como $f \neq 0$, por (i) temos que $g\ -\ h\ =\ 0$. $\square$
\end{proof}

\begin{lemma} \label{lema1} Suponhamos que $f$ e $d$ sejam polinômios não nulos em $\mathbb{GF}_p[x]$ tais que $grau(d) \leq grau(f)$. Então $\exists g$ polinômio em $\mathbb{GF}_p[x]$ tal que ou $f-dg\ =\ 0$ ou  $\ grau(f-dg) < grau(f)$
\end{lemma}

\begin{proof} Suponhamos que
$$
\begin{array}{cl}
f\ =\ a_mx^m\ +\ \displaystyle\sum_{i=0}^{m-1} a_ix^i,\ a_m \neq 0\\\\
d\ =\ b_nx^n\ +\ \displaystyle\sum_{i=0}^{n-1} b_ix^i,\ b_n \neq 0
\end{array}
$$
Seja $m$ o grau de $f$ e $n$ o grau de $d$. Então $m > n$. Suponhamos que $g\ =\ \frac{f}{d}$. Vamos tomar o polinômio $g^{'}$ igual ao termo de $g$ de maior grau:
$$
\begin{array}{cl}
g\ =\ \frac{a_m}{b_n}x^{m-n}\ +\ \ldots\\
g^{'}\ =\ \frac{a_m}{b_n}x^{m-n}
\end{array}
$$
Se tomarmos $g\ =\ g^{'}\ =\ \frac{a_m}{b_n}x^{m-n}$,
$$
\begin{array}{cl}
f - \frac{a_m}{b_n}x^{m-n}\ =\ 0\ ou\\
grau(f-\frac{a_m}{b_n}x^{m-n}) < grau(f)
\end{array}
$$
$\square$
\end{proof}

Usando o lemma~\ref{lema1}, podemos mostrar que a operação de divisão de polinômios pode ser feita em $\mathbb{GF}_p[x]$.

\begin{definition} Seja $f, g \in \mathbb{GF}_p[x]$, $f$ e $g$ polinômios e $g$ não nulo. Existem um par de polinômios únicos $q$ e $r$ tal que $f(x)\ =\ q(x)g(x)\ +\ r(x)$, com $grau(r(x)) < grau(g(x))$.
\end{definition}

\begin{definition} {\bf Polinômio Irredutível} \label{PolIrred} \index{Polinômio Irredutível} Seja $p(x)$ um polinômio de grau $m$ sobre $\mathbb{GF}_2$. Se $p(x)$ não for divisível por nenhum polinômio de $grau \leq m-1$, então $p(x)$ é irredutível sobre $\mathbb{GF}_2$.
\end{definition}

\begin{proposition}
$\forall$ polinômio irredutível sobre $\mathbb{GF}_2$ de grau $m$ divide $x^{2^m-1} + 1$.
\end{proposition}

\begin{definition} {\bf Polinômio Primitivo} \label{PolPrim} \index{Polinômio Primitivo}
Seja $p(x)$ um polinômio de grau $m$ sobre $\mathbb{GF}_2$. Se $2^m-1$ for o menor inteiro positivo para o qual $p(x)$ divide $x^{2^m-1} + 1$, então $p(x)$ é um polinômio primitivo de grau $m$ sobre $\mathbb{GF}_2$.
\end{definition}

\begin{definition} {\bf Polinômio Redutível e Irredutível} \label{PolRedIrred} \index{Polinômio Redutível e Irredutível} Dado um corpo $\mathbb{GF}_p[x]$, um polinômio $f$  é redutível em $\mathbb{GF}_p[x]$, se existem os polinômios $g, h$ em $\mathbb{GF}_p[x]$ de grau $\geq 1$ tais que $f\ =\ gh$ e $f$ e senão, $f$ é irredutível em $\mathbb{GF}_p[x]$.
\end{definition}

\begin{proposition}
Seja $F[x]$ um polinômio irredutível de grau $n$ em $GP_p[x]$. Então $GP_p[x]/F[x]$ é um corpo finito com $p^n$ elementos.
\end{proposition}

\begin{theorem} Seja $P[x]$ um irredutível polinômio sob $\mathbb{GP}_p$ e cujo grau é $m$. Então o conjunto de todos os polinômios em $x$ de grau $m-1$ e coefientes $\in \mathbb{GP}_p$ com as operações adição e multiplicação módulo-$2$ é um campo de ordem $p_m$.
\end{theorem}

\section{Polinômios sobre $\mathbb{GF}_q$}

Códigos de bloco são construídos com elementos de um corpo $\mathbb{GF}_q$ onde $q$ ou é primo $p$ ou uma potência de $p$. Os dados de sistemas de transmissão e armazenamento de dados podem ser facilmente codificados em códigos com símbolos gerados a partir de um corpo $\mathbb{GF}_2$ ou $\mathbb{GF}_{2^m}$ \cite{Lin:1983}.

\begin{definition} {\bf Código Binário} \label{CodBin} \index{Código Binário} Código binário é um código em que o número de palavras de código é $2^m$, ou seja, $q = 2$.
\end{definition}

O corpo $\mathbb{GF}_{2^m}$ consiste de todos os polinômios $P$ em $\alpha$ de grau $\leq m-1$ com coeficientes em $\mathbb{GF}_2$. Um elemento em $\mathbb{GF}_{2^m}$ é da forma: 

\begin{align*}
a_0a_1 \ldots a_{m-1} \leftrightarrow a_0\ +\ a_1\alpha\ + \ldots +\ a_{m-1}\alpha^{m-1}
\end{align*}

onde $a_i \in \mathbb{GF}_2$ e $P(\alpha)\ =\ 0$

Na representação polinomial, o elemento primitivo $\alpha$ é a raiz do polinômio primitivo $p(x)$ de grau $m$. Essa representação é usada para a operação adição de dois elementos de $\mathbb{GF}_{2^m}$.

\begin{example}
Considere o campo $\mathbb{GF}_{2^4}$ definido pelo polinômio primitivo $p(x)=1 + x^3 + x^4$.  O campo tem $2^4=16$ elementos. Esses serão os símbolos usados pelo código. A representação binária é expressa pela pela tupla $(x^4, x^3, x^1, x^0)$. Na representação exponencial, o elemento nulo e os 4 primeiros elementos não nulos $\alpha, \alpha^2, \alpha^3, \alpha^4$ são expressos de forma trivial. Para obter a representação dos outros elementos $\alpha^5, \ldots , \alpha^{14}$ é necessário usar o polinômio primitivo. Para isso, define-se $\alpha$ raiz do polinômio primitivo: \footnote{Na aritmética binária, -1= +1.}
\begin{align*}
p(\alpha) = 0\\
1 + \alpha + \alpha^4 = 0\\
\alpha^4 = -1-\alpha = 1+\alpha
\end{align*}
Para se obter os elementos:
\begin{align*}
\alpha^5 = \alpha.\alpha^4 = \alpha.(1+ \alpha) = \alpha + \alpha^2\\
\alpha^6 = \alpha.\alpha^5 = \alpha^2 + \alpha^3\\
\alpha^7 = \alpha.\alpha^6 = \alpha^3 + \alpha^4 = 1 + \alpha + \alpha^3\\
\alpha^8 = \alpha.\alpha^7 = \alpha + \alpha^2 + \alpha^4  = \alpha + \alpha^2 + 1 + \alpha = 1 + \alpha^2\\
\alpha^9 = \alpha.\alpha^8 = \alpha + \alpha^3\\
\alpha^{10} = \alpha.\alpha^9 = \alpha^2 + \alpha^4\\
\alpha^{11} = \alpha.\alpha^{10} = \alpha + \alpha^2 + \alpha^3\\
\alpha^{12} = \alpha.\alpha^{11} = \alpha^2 + \alpha^3 + \alpha^4 = 1 + \alpha + \alpha^2 + \alpha ^3\\
\alpha^{13} = \alpha.\alpha^{12} = \alpha + \alpha^2 + \alpha^3 + \alpha^4 = \alpha + \alpha^2 + \alpha^3 + 1 + \alpha = 1 + \alpha^2 + \alpha^3\\
\alpha^{14} = \alpha.\alpha^{13} = \alpha + \alpha^3 + \alpha^4 = \alpha + \alpha^3 + 1 + \alpha = 1 + \alpha^3\\
\alpha^{15} = \alpha.\alpha^{14} = \alpha^0
\end{align*}

\input{tabelas/tabela-representacao-corpo-galois8}

\end{example}

O campo $\mathbb{GF}_{256}$ é um espaço vetorial sob $\mathbb{GF}_2$ de dimensão $8$ e é muito usado para construir códigos de bloco. A aritmética
binária utiliza adição e multiplicação módulo-$2$. Um polinômio $F[x]$ definido sobre $\mathbb{GF}_2$ possui a forma:
\begin{align*}
P[x]\ =\ a_o\ +\ a_1x\ +\ a_2x^2\ + \ldots +\ a_{n-1}x^{n-1}\ +\ a_nx^n\\
com\ a_i \in \{0, 1\}\ e\ n \in \{0, 1, 2, 3, 4, 5, 6, 7\}
\end{align*}


\section{Construção de $\mathbb{GF}_q$ (Galois Estendido)}

\begin{definition} {\bf Representação Exponencial} \label{RepExp} \index{Representação Exponencial} Seja $\alpha$ um elemento primitivo em $\mathbb{GF}_q, q=2^m$. Então $\alpha$ tem ordem $q -1$ e as potências distintas de $\alpha$ $\{ 1, \alpha, \alpha^2, \ldots \alpha^{q-2}\}$ geram todos os elementos diferentes de $0$ de $\mathbb{GF}_q$.

A representação exponencial é utilizada na operação multiplicação de dois elementos do $\mathbb{GF}_q$, pois $\alpha^i.\alpha^j=\alpha^{i+j}$.

\end{definition}

\begin{definition} Um polinômio $p(x)$ irredutível sobre $\mathbb{GF}_q$ de grau $m$ é um polinômio primitivo se suas raízes forem um elemento de $\mathbb{GF}_q$.
\end{definition}

\begin{definition} Seja $p(x)$ um polinômio com coeficientes em $\mathbb{GF}_2$. Seja $\beta \in \mathbb{GF}_q$. Se $\beta$ é uma raiz de $p(x)$, então $\forall l \geq 0,\ \beta^{2^{l}}$ é também uma raiz de $p(x)$. O elemento $\beta^{2^{l}}$ é chamado conjugado de $\beta$.
\end{definition}

\begin{theorem} {\bf Raízes do Polinômio} \label{RaiPol} \index{Raízes do Polinômio} Os $2^m -1$ elementos diferentes de $0 \in \mathbb{GF}_q$ são as raízes do polinômio $x^{2^{m}-1} + 1$.
\end{theorem}

\begin{corollary} Para todos os elementos $ \in \mathbb{GF}_q$, incluindo o elemento $0$, esses são as raízes do polinômio $x^{2^{m}-1} + x$.
\end{corollary}

\begin{definition} {\bf Polinômio Minimal} \label{PolMinimal} \index{Polinômio Minimal}  Seja $\beta \in \mathbb{GF}_q$. O polinômio minimal $\phi(x)$ de $\beta$ é o polinômio de menor grau com coeficientes em $\mathbb{GF}_2$ tal que $\phi(\beta)=0$.
\end{definition}

\begin{theorem} Seja $\phi(x)$ o polinômio minimal de um elemento $\beta \in \mathbb{GF}_q$ e $e$ o menor inteiro tal que $\beta^{2^{e}}=\beta$. Então $\phi(x)= \displaystyle\prod\limits_{i=0}^{e-1} (x + \beta^{2^{i}})$
\end{theorem}

\begin{definition} {\bf Polinômio Gerador} \label{PolGer} \index{Polinômio Gerador} Seja $C:(m,k)$ um código cíclico sobre $\mathbb{GF}_q$. $\exists g(x)$ de grau $1$, tal que uma $m$-tupla $c \in C:(m,k)$ é uma palavra-código se, e somente se, $g(x)\ |\ c$ .
\end{definition}

\begin{property} O polinômio gerador é único. O grau do polinômio gerador é $m-k$ e seu grau é igual ao número de bits de paridade. $g(x)$ é o polinômio código de menor grau entre todos os polinômios código. O polinômio gerador é um divisor de $x^m -1$. Todo polinómio código é um múltiplo do polinômio gerador.
\end{property}

\begin{proposition} O polinómio código não nulo de grau mínimo de um determinado código cíclico $C:(m,k)$ é único.
\end{proposition}

\begin{proof} Esse polinômio terá a forma $g(X) = g_0 + g_1X + \ldots + X^r$ . Se existir outro polinômio com grau mínimo, este polinômio será da forma $g1 (X) = g_{10} + g_{11} X + \ldots + X^r$ . No entanto, porque o código $C:(m,k)$  é um código de bloco linear, a soma destes dois códigos
polinómios deverá pertencer ao código, e esta soma nos fornece um polinômio de grau $(r-1)$, o que contradiz a hipótese que o grau mínimo possível é $r$. logo, o polinômio código não nulo de grau mínimo de um determinado código cíclico $C:(m,k)$ é único. $\square$
\end{proof}

\begin{definition} O polinômio gerador $g(x)$ é da forma $g[x]\ =\ 1\ +\ g_1x\ +\ g_2x^2\ + \ldots +\ g_{m-k}x^{m-k}$.
\end{definition}

\begin{proposition} Seja $a(x)= \ ao\ +\ a_1x\ +\ a_2x^2\ + \ldots +\ a_{k-1}x^{k-1}$. Então, $(a(x)g(x)\ mod\ (x^m -1)) \in C(m,k)$.
\end{proposition}

\begin{proof} $a(x)g(x)$ pode ser escrito da seguinte forma: 
\begin{align*}
\underbrace{a_og(x)}_{\in C} + \underbrace{a_1g(x)}_{\in C} + \ldots + \underbrace{a_{k-1}x^{k-1}g(x)}_{\in C}
\end{align*}
Portanto,  $a(x)g(x) \in C$.  
\end{proof}

\begin{definition} {\bf Código de Blocos Linear} \label{CodBlocLin} \index{Código de Blocos Linear} Um código de bloco de tamanho $m$ e $2^k$ palavras mensagem é denominado um código de blocos linear $C:(m,k)$, se as $2^k$ palavras código formam um subespaço vetorial $S$ de dimensão k, contido no espaço de vetores formado por todos os vetores de tamanho $m$, $V_m$, com componentes no $\mathbb{GF}_2$. Um código é linear, quando o elemento  nulo pertence ao código e a soma de duas palavras código também é uma palavra código.
\end{definition}

\begin{definition} {\bf Matriz Geradora Não Sistemática} \label{matger} \index{Matriz Geradora Não Sistemática} Seja $C:(m,k)$ um código de blocos linear. Existem $k$ vetores linearmente independentes tal que cada palavra código $c$ pode ser escrita como uma combinação linear deles.
\begin{align*}
c=v_0g_0 \oplus v_1g_1 \oplus \ldots \oplus v_{k-1}g_{k-1}
\end{align*}
Esses vetores podem ser organizados em um matriz geradora $G$
\begin{align*}
G=\left[\begin{array}{c}
g_0\\
g_1\\
\vdots\\
g_{k-1}
\end{array}\right]=
\left[\begin{array}{cccc}
g_{0,0} & g_{0,1} & \ldots & g_{0,m-1}\\
g_{1,0} & g_{1,1} & \ldots & g_{1,m-1}\\
\vdots & \vdots & \vdots & \vdots\\
g_{k-1,0} & g_{k-1,1} & \ldots & g_{k-1,m-1}\\
\end{array}\right]
\end{align*}
Todo vetor $v$, a mensagem a ser enviada ou armazenada pode ser  obtido através da multiplicação de matrizes:
\begin{align*}
{\bf c} = {\bf vG} = (v_0, v_1, \ldots, v_{k-1})
\left[\begin{array}{cccc}
g_{0,0} & g_{0,1} & \ldots & g_{0,m-1}\\
g_{1,0} & g_{1,1} & \ldots & g_{1,m-1}\\
\vdots & \vdots & \vdots & \vdots\\
g_{k-1,0} & g_{k-1,1} & \ldots & g_{k-1,m-1}\\
\end{array}\right]
\end{align*}
\begin{align*}
= (v_0, v_1, \ldots, v_{k-1})
\left[\begin{array}{c}
g_0\\
g_1\\
\vdots\\
g_{k-1}
\end{array}\right]=v_0g_0 \oplus v_1g_1 \oplus \ldots \oplus v_{k-1}g_{k-1}
\end{align*}
As linhas da matriz geradora $G$ geram o código de blocos linear $C:(m,k)$, ou seja, as $k$ linhas linearmente independentes de $G$ definem completamente o código.
\end{definition}

\begin{definition} {\bf Matriz Geradora Sistemática} \label{matger} \index{Matriz Geradora Sistemática}  Um código de blocos linear e sistemático $C:(m,k)$ é especificado de forma única por uma matriz geradora da forma:
\begin{align*}
G=\left[\begin{array}{c}
g_0\\
g_1\\
\vdots\\
g_{k-1}
\end{array}\right]=
\left[\begin{array}{ccccccccc}
p_{0,0} & p_{0,1} & \ldots & p_{0,m-k-1} & 1 & 0 & 0 & \ldots & 0 \\
p_{1,0} & p_{1,1} & \ldots & p_{1,m-k-1} & 0 & 1 & 0 & \ldots & 0\\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots\\
p_{k-1,0} & p_{k-1,1} & \ldots & p_{k-1,m-k-1} & 0 & 0 & 0 & \ldots & 1
\end{array}\right]
\end{align*}
ou, de uma forma mais compacta:
\begin{align*}
{\bf G} = \left[ {\bf P I_k} \right]
\end{align*}
onde {\bf $P$} é a matriz de paridade.
\end{definition}

\begin{definition} {\bf Matriz de Verificação de Paridade} \label{matverpar} \index{Matriz de Verificação de Paridade}  Em um código de blocos linear e sistemático $C:(m,k)$,  as $2^k$ palavras código formam um subespaço vetorial $S$ associado a um subespaço dual $S_d$ do mesmo espaço $V_m$ que é gerado pela matriz de verificação de paridade $H$. Cada vetor linha da matriz $G$ é ortogonal às linhas da matriz $H$ e vice-versa. Assim, cada código tem um dual que é o código gerado pela matriz $H$. Este código é um código $(n, n - k)$. A forma sistemática da matriz de paridade $H$ do código $C$, gerado pela matriz $G$ é:
\begin{align*}
{\bf H} =\left[\begin{array}{ccccccccc}
1 & 0 & 0 & \ldots & 0 & p_{0,0} & p_{1,0} & \ldots & p_{k-1,0}\\
0 & 1 & 0 & \ldots & 0 & p_{0,1} & p_{1,1} & \ldots & p_{k-1,1}\\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots\\
0 & 0 & 0 & \ldots & 1 & p_{0,m-k-1} & p_{1,m-k-1} & \ldots & p_{k-1,m-k-1}\\
\end{array}\right]=\left[ {\bf I_{n-k}P^T} \right]
\end{align*}
onde {\bf $P^T$} é a transposta da matriz de paridade {\bf $P$}. A matriz {\bf $H$} é construída tal que 
\begin{align*}
{\bf GH^T} = {\bf 0} 
\end{align*}
\end{definition}

\begin{definition} {\bf Síndrome de Detecção de Erro} \label{sindrome} \index{Síndrome de Detecção de Erro} Após a recepção ou a leitura da palavra código $c$, temos o vetor $r=r_0r_1 \ldots r_{m-1} \in  \mathbb{GF}_2$. O vetor $r$ pode ser diferente do vetor $c$ transmitido ou armazenado. Seja o vetor $e=e_0e_1 \ldots e_{m-1} \in \mathbb{GF}_2$ tal que $e=r \oplus c$. Um mecanismo de detecção de erro pode ser implementado tal que {\bf $cH^T=0$}, o vetor síndrome:
\begin{align*}
S = rH^T = (s_os_1 \ldots s_{m-k-1}) = (c \oplus e)H^T=cH^T \oplus eH^T = e H^T
\end{align*}
Se o padrão de erro for igual a uma palavra código, o erro não será detectado. Existem $2^k -1$ padrões de erros não detectáveis. O vetor síndrome pode ser calculado da forma:
\begin{align*}
s_0=e0 \oplus e_{m-k} \otimes p_{0,0} \oplus e_{m-k+1} \otimes e_{1,0} \oplus \ldots \oplus  e_{m-1} \otimes p_{k-1,0}\\
s_1=e1 \oplus e_{m-k} \otimes p_{0,1} \oplus e_{m-k+1} \otimes e_{1,1} \oplus \ldots \oplus  e_{m-1} \otimes p_{k-1,1}\\
\vdots\\
s_{n-k-1}=e_{m-k-1} \oplus e_{m-k} \otimes p_{0,m-k+1} \oplus e_{m-k+1} \otimes e_{1,m-k+1} \oplus \ldots \oplus  e_{m-1} \otimes p_{k-1,m-k+1}
\end{align*}
\end{definition}

\begin{example} {\bf Código Hamming} \label{CodHamm} \index{Código Hamming}
No seu artigo~\cite{Hamming:1950}, R. Hamming propôs uma codificação que levou o seu nome. Para $\forall m \geq 3$, $\exists\ CH:(n,k)$, um código hamming com as seguintes características: comprimento da palavra código é $n=2^m -1$, número de bits de dados na mensagem é $k=2^m-m-1$, número de bits de paridade é $m=n-k$, capacidade de correção de erros é $t=1$, distância mínima é $d_{min} = 3$ e capacidade de detecção de erros é $l=2$. Para $m=3$, $n=7$, $k=4$ e para a matriz geradora ${\bf G}$, a matriz ${\bf H}$ desse $CH:(7,4)$ é:
\begin{align*}
{\bf G} = {\bf PI_4} = \left[\begin{array}{ccccccc}
1 & 1 & 0 & 1 & 0 & 0 & 0\\
0 & 1 & 1 & 0 & 1 & 0 & 0\\
1 & 1 & 1 & 0 & 0 & 1 & 0\\
1 & 0 & 1 & 0 & 0 & 0 & 1
\end{array}\right]
{\bf H} = \left[ {\bf I_{n-k}P_T} \right] \left[\begin{array}{ccccccc}
1 & 0 & 0 & 1 & 0 & 1 & 1\\
0 & 1 & 0 & 1 & 1 & 1 & 0\\
0 & 0 & 1 & 0 & 1 & 1 & 1
\end{array}\right]
\end{align*}
O vetor síndrome $S=(s_0, s_1, s_2)= (e_0, e_1, e_2, e_3, e_4 e_5 e_6){\bf H^T}=$. Então
\begin{align*}
s_0=e_0 \oplus e_3 \oplus e_5 \oplus e_6\\
s_0=e_1 \oplus e_3 \oplus e_4 \oplus e_5\\
s_0=e_2 \oplus e_4 \oplus e_5 \oplus e_6
\end{align*}
Uma mensagem inicial $(1010)$ foi enviada ou armazenada como $c=(1010){\bf G}=(0011010)$ e foi recebida ou lida como $r=(0001010)$. O vetor síndrome é $S=(001)$. Existem $2^4$ padrões de erro que satisfazem esse sistema de equações que podem ser vistos na tabela ~\ref{tab8:map}.

\input{tabelas/tabela-padroes-erros-codigo-hamming}

Para canais como o canal simétrico binário (BSC), o padrão de erros com menor número de erros é considerado o padrão correto e ele segue uma distribuição binomial.

\begin{align*}
0=e_0 \oplus e_3 \oplus e_5 \oplus e_6\\
0=e_1 \oplus e_3 \oplus e_4 \oplus e_5\\
1=e_2 \oplus e_4 \oplus e_5 \oplus e_6
\end{align*}

Assim, podemos calcular $c=r \oplus e= (0001010) \oplus (0010000)=(0011010)$. Como utilizamos a matriz geradora sistemática, a mensagem inicial é $(1010)$.

\end{example}


\section{Construção de um Código Corretor de Erros}

%		\subsection{Métrica de Hamming}
%		página 4 - livro Hefez
%		página 7 - Parâmetros fundamentais $[n, M, d]$



O objetivo da codificação de canal é aumentar a resistência do sistema de comunicações digital face aos efeitos do ruído de canal. No caso particular dos códigos de bloco, a cada bloco de k bits da sequência binária gerada pela fonte faz-se corresponder um bloco de $m$ bits (palavra de código) com $m > k$. Este processo de codificação deve ser concebido de modo que a decodificação tenha solução única. Note-se que do universo de $2m$ blocos binários de comprimento $m$ apenas $2k$ são palavras de código (as que correspondem numa relação de um para um aos blocos binários de comprimento $k$ gerados pela fonte). Este esquema está representado simbolicamente na Figura~\ref{fig3:cod}. 8.4. No caso de a transmissão se efetivar sem erros, o processo de decodificação conduz ao bloco de comprimento $k$ que havia sido gerado pela fonte. Quando ocorrem erros de transmissão, a palavra de comprimento $m$ recebida pode não ser uma palavra de código e o erro é detectado e/ou corrigido.
Figura 8.4: Codificação de canal

                \vspace*{2cm}
		\begin{figure}[h]
		\setlength{\unitlength}{1cm}
			\begin{picture}(6, 4)
				\put(2, 2){\circle{2}}
				\put(1.7, 2){$2^k$}
				\put(1, 0.8){codificação}
				\put(2.3, 1.8){\circle*{0.1}}
				\put(4.5, 2){\circle{2}}
				\put(4.2, 2){$2^k$}
				\put(4.6, 1.8){\circle*{0.1}}
				% Ellipse: u = 4.5 v = 2.5 a = 1.5 b = 1.5 phi = 0.0 Grad
				\qbezier(6.0, 2.5)(6.0, 3.1213)(5.5607, 3.5607)
				\qbezier(5.5607, 3.5607)(5.1213, 4.0)(4.5, 4.0)
				\qbezier(4.5, 4.0)(3.8787, 4.0)(3.4393, 3.5607)
				\qbezier(3.4393, 3.5607)(3.0, 3.1213)(3.0, 2.5)
				\qbezier(3.0, 2.5)(3.0, 1.8787)(3.4393, 1.4393)
				\qbezier(3.4393, 1.4393)(3.8787, 1.0)(4.5, 1.0)
				\qbezier(4.5, 1.0)(5.1213, 1.0)(5.5607, 1.4393)
				\qbezier(5.5607, 1.4393)(6.0, 1.8787)(6.0, 2.5)
				\put(4.5, 3.5){$2^m$}
				\put(2.3,1.8){\vector(4,0){2.3}}
				\put(10, 2){\circle{2}}
				\put(9.7, 2){$2^k$}
				\put(10.1, 1.6){\circle*{0.1}}
				\put(4.6,1.8){\vector(4,0){5}}
				\put(12.5, 2){\circle{2}}
				\put(12.2, 2){$2^k$}
				\put(12,0.8){decodificação}
				\put(12.8, 1.8){\circle*{0.1}}
				% Ellipse: u = 10.0 v = 2.5 a = 1.5 b = 1.5 phi = 0.0 Grad
				\qbezier(11.5, 2.5)(11.5, 3.1213)(11.0607, 3.5607)
				\qbezier(11.0607, 3.5607)(10.6213, 4.0)(10.0, 4.0)
				\qbezier(10.0, 4.0)(9.3787, 4.0)(8.9393, 3.5607)
				\qbezier(8.9393, 3.5607)(8.5, 3.1213)(8.5, 2.5)
				\qbezier(8.5, 2.5)(8.5, 1.8787)(8.9393, 1.4393)
				\qbezier(8.9393, 1.4393)(9.3787, 1.0)(10.0, 1.0)
				\qbezier(10.0, 1.0)(10.6213, 1.0)(11.0607, 1.4393)
				\qbezier(11.0607, 1.4393)(11.5, 1.8787)(11.5, 2.5)
				\put(10, 3.5){$2^m$}
				\put(9.7, 3.2){\circle*{0.1}}
  	 		\end{picture}
   			\caption{Codificação de canal}
   			\label{fig3:cod}
		\end{figure}

É de especial interesse o caso de $\mathbb{GF}_q, q=2^m,\ m = 8$, quando cada símbolo representa 1 byte. Um byte representa 8 bits, que é a menor palavra de dados usualmente encontrada em sistemas de computadores.


O campo $\mathbb{GF}_{2^8-1}$ usado para construir a codificação RS implementada no Hadoop consiste de polinômios $P[x]$ com coeficientes binários e grau até $7 ?$ e as operações de adição e multiplicação, calculadas módulo o polinômio irredutível $P[x]\ =\ x^8 + x^4 + x^3 + x^2 + 1$.

%Teoria da Informação: Capacidade do Canal de Transmissão

%Codificação de Canal: Códigos de Bloco Lineares



